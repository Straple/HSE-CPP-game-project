# База
В компьютерах время симулируется через счётчик, который после определенного (константного) интервала времени увеличивается на **1**. Такое называется тики.

**TODO:** нарисовать картинку для понимания

**get_performance_frequency()** вернет частоту обновления тиков устройства, то есть количество тиков в секунду. Если не получилось их найти (я не знаю, как это может произойти, но будем следовать документации той функции), то упадет ассерт.

**get_ticks()** вернет текущий тик. Опять же упадет ассерт, если что-то не получилось.

У меня **10^7** тиков в секунду (я так понимаю, что у многих будет также). Это позволяет подсчитывать время в высокой точности.

### Example
```
auto start_tick = get_ticks();
// do something
auto end_tick = get_ticks();
std::cout << (end_tick - start_tick) / perfomance_frequency;
```

Здесь **performance_frequency** это глобальная константная переменная типа **efloat** полученная с помощью **get_performance_frequency()**, чтобы лишний раз не вызывать.

**std::cout** выпишет время в секундах потраченное на **do something**

# Timer

Также для удобства использования есть класс **Timer**, который при своем создании (конструктор по умолчанию) сохраняет указатель на текущий тик. При вызове метода **get()** будет получено время в секундах от времени указателя тика до текущего. Также можно обновить указатель времени с помощью **reset()** или получить его **get_tick()**. И конечно переменную можно выводить через **<<**, чтобы получить время между текущим и указателем.

### Example

```
Timer t;
// do something
std::cout << t << '\n'; // например "0.0000s"
t.reset();
// do something 2
std::cout << t << '\n'; // например "0.5033s"
```

Первый **std::cout** выпишет время потраченное на **do something** (и "s" в конце для красоты). После чего указатель времени обновится с помощью **reset()** и тогда второй **std::cout** выпишет время потраченное на **do something 2**.

# Немного о движке

В движке очень аккуратно обновляется время между кадрами, чтобы не терять такую драгоценную информацию между вызовами **get_ticks()** и не накапливать потерю.