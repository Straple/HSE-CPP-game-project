# Geometry
В игровом движке есть куча геометрии.

# Dot(x,y)
Хранит позицию на плоскости. У него есть куча различных операций:

* **Dot() = (0, 0)** конструктор по умолчанию

* **Dot(x, y) = (x, y)** конструктор от **x**, **y**

* **-Dot(x, y) = (-x, -y)** унарный **-**

* **Dot(x1, y1) + Dot(x2, y2) = Dot(x1 + x2, y1 + y2)** сложение векторов

* **Dot(x1, y1) - Dot(x2, y2) = Dot(x1 - x2, y1 - y2)** вычитание векторов

* аналогичные с **+=**, **-=**

* **Dot(x, y) \* k = Dot(x \* k, y \* k)** умножение вектора на скаляр справа

* **k \* Dot(x, y) = Dot(x \* k, y \* k)** умножение вектора на скаляр слева

* аналогично **\*= k**

* **Dot(x, y) / k = Dot(x / k, y / k)** деление вектора на скаляр

* аналогично **/=**

* **Dot(x, y).get_quare_len() =** квадрат длины вектора

* **Dot(x, y).get_len() =** длина вектора. Вычисляется с помощью **hypot(x,y)**, что в **~20** раз медленней **sqrt(x^2 + y^2)**, но очень точно.

* **Dot(x, y).normalize() =** нормализованный вектор (получается вектор такого же направления, но длины **1**). Если вектор нулевой длины (или очень близок к нулю), то вернет **Dot()**

* **Dot == Dot** проверяет на очень близкое равенство точек

* **Dot != Dot** аналогично

* **Dot < Dot** меньше будет самая левая, а при равенстве **x**-ов самая нижняя

* аналогично **Dot > Dot**

* **Dot % Dot =** косое/векторное произведение. Это площадь параллелограмма, образованного этими векторами

* **Dot * Dot =** скалярное произведение векторов. По его знаку можно узнать расположение двух векторов относительно друг друга. Еще можно посчитать угол

* **output << Dot** выводит **"Dot(x, y)"**, вместо **x** и **y** подставляет значения

* **input >> Dot** считывает **"Dot(x, y)"**, если будет не по формату, то упадет ассерт (слишком сложную бяку он не отлавливает).  