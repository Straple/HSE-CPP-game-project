# DOCUMENTATION

# ASSERT(condition, message)

Макрос. Проверяет, что условие верно. Если это не так, то выводит сообщение об ошибке и завершает работу. Полезен, так как в играх много инвариантов и их все необходимо учитывать.

example

![image](https://user-images.githubusercontent.com/54230867/221960861-44a337e2-8109-4bbc-bec7-6ffaf688fd71.png)
![image](https://user-images.githubusercontent.com/54230867/221961266-88e8071a-dbe1-4d95-a4fd-f938d488a290.png)

implementation in assert.h

![image](https://user-images.githubusercontent.com/54230867/221961669-9f15675f-189c-4cac-a03d-3228bf70807f.png)

# clamp(min, val, max)

Возвращает значение между min и max. Удобно, так как можно например легко удерживать позицию предмета между некоторыми границами. Должно быть выполнено min <= max, иначе упадет ассерт.

implementation in utils.h

![image](https://user-images.githubusercontent.com/54230867/221964455-a50ea4b8-88a8-48b2-8700-a02ebfff701c.png)

# is_between(min, val, max)

Проверяет, что val лежит между min и max. Удобен для читабельности кода, так как не нужно дважды писать вычисление val (вдруг это формула какая-то) и писать <=. Должно быть выполнено min <= max, иначе упадет ассерт.

implementation in utils.h

![image](https://user-images.githubusercontent.com/54230867/221968706-325d1734-db78-491e-9db5-33f7fda05a4e.png)


# to_string(val)

Обертка над std::to_string(val). Нужна чтобы переопределить to_string для efloat и выписывать его с определенной точностью для однообразности. Используется для отрисовки плавающих чисел на экран.

implementation in utils.h

![image](https://user-images.githubusercontent.com/54230867/221967929-e8d29afd-95fe-4598-b80d-28086af892cf.png)


# TIME

В компьютерах время симулируется через счётчик, который после определенного (константного) интервала времени увеличивается на 1. Такое называется тики.

TODO: нарисовать картинку для понимания

get_performance_frequency() вернет частоту обновления тиков устройства, то есть количество тиков в секунду. Если не получилось их найти (я не знаю, как это может произойти, но будем следовать документации той функции), то упадет ассерт.

get_ticks() вернет текущий тик. Опять же упадет ассерт, если что-то не получилось.

У меня 10^7 тиков в секунду (я так понимаю, что у многих будет также). Это позволяет подсчитывать время в высокой точности.

example

![image](https://user-images.githubusercontent.com/54230867/221977116-da28f0d4-c3a8-41ee-981d-5eaf3dc39caa.png)

Здесь performance_frequency это глобальная константная переменная полученная с помощью get_performance_frequency(), чтобы лишний раз не вызывать.

std::cout выпишет время в секундах потраченное на do something

Timer

Также для удобства использования есть класс Timer, который при своем создании (конструктор по умолчанию) сохраняет указатель на текущий тик. При вызове get() этого класса будет получено время в секундах от времени указателя тика до текущего. Также можно обновить указатель времени с помощью reset() или получить его get_tick(). И конечно переменную можно выводить, чтобы получить время между текущим и указателем.

example

![image](https://user-images.githubusercontent.com/54230867/221980734-cd8f4376-e1e9-4117-b206-0afafff71193.png)

![image](https://user-images.githubusercontent.com/54230867/221981684-51a8edb6-ff69-4f73-92a2-b0bea11fe3b6.png)

Первый std::cout выпишем время потраченное на do something (и "s" в конце для красоты). После чего указатель времени обновится с помощью reset() и тогда второй std::cout выпишет время потраченное на do something 2.


В движке очень аккуратно обновляется время между кадрами, чтобы не терять такую драгоценную информацию между вызовами get_ticks() и не накапливать эту потерю

![image](https://user-images.githubusercontent.com/54230867/221982929-d5b6fc83-b558-40c6-8e3a-45e66dc321c1.png)
